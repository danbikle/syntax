.q1 Question:
.q2 What is 2015_1010 Code Challenge?
.tags
  %span.tagtag Tags:
  %a.xtag(href='/tags/npm') npm
  %a.xtag(href='/tags/nodejs') nodejs
  %a.xtag(href='/tags/linux') linux
  %a.xtag(href='/tags/ubuntu') ubuntu
  %a.xtag(href='/tags/heroku') heroku
  %a.xtag(href='/tags/package_json') package_json
  %a.xtag(href='/tags/javascript') javascript
  %a.xtag(href='/tags/coffeescript') coffeescript
  %a.xtag(href='/tags/useradd') useradd
  %a.xtag(href='/tags/passwd') passwd
  %a.xtag(href='/tags/git') git
  %a.xtag(href='/tags/procfile') procfile
  %a.xtag(href='/tags/node') node
  %a.xtag(href='/tags/node_modules') node_modules
  %a.xtag(href='/tags/gitignore') gitignore
  %a.xtag(href='/tags/engines') engines
  %a.xtag(href='/tags/http_server') http_server
  %a.xtag(href='/tags/toolbelt') toolbelt
  %a.xtag(href='/tags/code_challenge') code_challenge
  %a.xtag(href='/tags/bikle101') bikle101
  %a.xtag(href='/tags/emacs') emacs
  %a.xtag(href='/tags/buffer_menu') buffer_menu
  %a.xtag(href='/tags/ssh') ssh
  %a.xtag(href='/tags/meetup') meetup
  %a.xtag(href='/tags/id_rsa') id_rsa
  %a.xtag(href='/tags/alert') alert
  %a.xtag(href='/tags/herokuapp') herokuapp
  %a.xtag(href='/tags/cedar') cedar
  %a.xtag(href='/tags/curl') curl
  %a.xtag(href='/tags/heroku_client') heroku_client
  %a.xtag(href='/tags/wget') wget
  %a.xtag(href='/tags/coffee') coffee
  %a.xtag(href='/tags/console_log') console_log
  %a.xtag(href='/tags/dired') dired
  %a.xtag(href='/tags/global_set_key') global_set_key
  %a.xtag(href='/tags/lisp') lisp
  %a.xtag(href='/tags/d3') d3
  %a.xtag(href='/tags/newyork212') newyork212
  %a.xtag(href='/tags/hsl') hsl
  %a.xtag(href='/tags/select') select
  %a.xtag(href='/tags/selectall') selectall
  %a.xtag(href='/tags/anonymous') anonymous



%br/

The 2015_1010 Code Challenge is a learning exercise for students attending Dan's Linux JavaScript Class at 3pm on 2015-10-10 at Hacker Dojo:

%br/
%br/

%a(href='http://www.meetup.com/Dans-Linux-JavaScript-Class/events/225843604/' target='w')
  http://www.meetup.com/Dans-Linux-JavaScript-Class/events/225843604/

%br/
%br/

We start with three tasks: Install Ubuntu, enhance it, and create account named ann:

%ul
  %li Install Ubuntu 14.04.3 on your laptop
  %li
    Useful:
    %a(href='http://releases.ubuntu.com/14.04/ubuntu-14.04.3-desktop-amd64.iso' target='w')
      http://releases.ubuntu.com/14.04/ubuntu-14.04.3-desktop-amd64.iso

  %li
    Useful:
    %a(href='https://www.virtualbox.org/wiki/Downloads' target='w')
      https://www.virtualbox.org/wiki/Downloads
    %br/
    %a(href='http://www.google.com/search?q=How+to+install+virtualbox' target='w')
      http://www.google.com/search?q=How+to+install+virtualbox    
    %br/
    %a(href='http://www.google.com/search?q=How+to+install+virtualbox+additions' target='w')
      How to install virtualbox guest additions
    %br/
    %a(href='/posts/virtualbox_why_tiny') virtualbox_why_tiny

  %li
    Enhance Ubuntu:
    %pre
      =render 'code_challenge2015_09121'

  %li
    Create account named ann:
    %pre
      %code.bash
        useradd ann -m -s /bin/bash
        passwd ann
        ssh -YA ann@localhost

Next, we learn some Emacs:

=render 'code_challenge2015_0919e'

%br/
%br/

/ Install node.js
=render 'code_challenge2015_0919n'

%ul
  %li
    Start work on an app:
    %pre
      %code.bash
        cd ~ann
        mkdir app20
        cd    ~ann/app20
        mkdir fee haml app

I did the above steps on my laptop.

%br/
%br/

Next, I used emacs to create a file named ~ann/app20/package.json

%pre
  =render 'code_challenge2015_1010a'

Then, I ran a simple shell command:

%pre
  %code.bash
    cd ~ann/app20
    npm install

That shell command created a folder named node_modules:

%pre
  %code.bash
    ann@red1:~/app20$ 
    ann@red1:~/app20$ ll node_modules/
    total 16
    drwxrwxr-x 4 ann ann 4096 Oct  8 23:58 ./
    drwxrwxr-x 6 ann ann 4096 Oct  8 23:58 ../
    drwxrwxr-x 2 ann ann 4096 Oct  8 23:58 .bin/
    drwxrwxr-x 8 ann ann 4096 Oct  8 23:58 http-server/
    ann@red1:~/app20$ 
    ann@red1:~/app20$ 
    ann@red1:~/app20$ 

I wanted git to ignore node_modules:

%pre
  %code.bash echo node_modules > ~ann/app20/.gitignore

Next, I created a git repository for the app20 folder:

%pre
  %code
    cd ~ann/app20
    git config --global user.email "ann@ann.edu"
    git config --global user.name ann
    git init
    git add .
    git commit -am app20IsHereNow
    git status
    git log -1

Then, I created ~ann/app20/app20env.bash

%pre
  =render 'code_challenge2015_1010b'

Next, I created a script to start http-server.

%pre
  =render 'code_challenge2015_1010c'

I started a shell in emacs and ran the above script.

%pre
  =render 'code_challenge2015_1010d'

That shell was locked; I renamed it so I could start another shell.

%br/
%br/

Next, I installed a Linux utility called HAML.

%pre
  =render 'code_challenge2015_1010e'

Then, I got a copy of d3.v3.min.js

%pre
  %code.bash
    cd ~ann/app20/app/
    curl https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js > d3.v3.min.js

Next, I created ~ann/app20/haml/demo10.haml

%pre
  =render 'code_challenge2015_1010demo10'

Then, I used the haml shell command to generate ~ann/app20/app/demo10.html

%pre
  %code.bash
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo10.haml ~ann/app20/app/demo10.html

Next, I checked that http-server was serving demo10.html

%pre
  %code.bash curl localhost:8080/app/demo10.html | head

Then, I browsed the URL and saw the page below:

%br/
%img(src='/images/code_challenge2015_1010demo10.png')
%br/
%br/

The main idea of the above demo is that when my browser loads d3.v3.min.js,
then I get access to an object named 'd3'.

%br/
%br/

A useful method of d3 is selectAll().

%br/
%br/

This method transforms HTML elements into JavaScript objects.

%br/
%br/

Then, I can manipulate the objects with calls to methods like style().

%br/
%br/

The methods then change HTML and CSS currently rendered in the browser.

%br/
%br/

This type of API behavior should seem natural and familiar to you if you have worked with jQuery.

%br/
%br/

I use two ideas when I work with this kind of API.

%br/
%br/

First, I use comments in the HTML which tell me when an element is affected by D3.

%br/
%br/

Secondly, I use a descriptive id or class name like "d3body" or "d3p" when I intend to control
an element with D3.

%br/
%br/

Why do I add comments and descriptive attributes to my HTML?

%br/
%br/

Well,
one feature of AngularJS which I like is that when I look at HTML controlled by AngularJS,
that control is obvious because of attributes with names like ng-app and ng-controller.

%br/
%br/

D3 does not have this feature so I manually annotate my HTML.

%br/
%br/

When I look at my code a year from now, I will easily connect my mind to the connections between the HTML and the D3 JavaScript due to my comments and class naming conventions.

%br/
%br/

Next, I worked on deploying my current copy of ~ann/app20 to heroku.com which is a popular free hosting service.


%br/
%br/

Heroku supports the following deployment idea:

%ul
  %li Create a simple Node.js app (~ann/app20 is  a simple Node.js app)
  %li Add a one-line-file named Procfile to the app
  %li git-init the app so I then have a git repo
  %li create an account at heroku.com
  %li download/install Heroku client
  %li Use heroku-client to "login" my shell
  %li Think of a unique app name (newyork212 for example)
  %li Use the client to create a blank app named newyork212 at herokuapp.com
  %li git-push ~ann/app20 to heroku
  %li see ~ann/app20 deployed at newyork212.herokuapp.com

%br/

What is the cost?

%br/
%br/

The cost is $0.00

%br/
%br/

The steps listed below demonstrate the above deployment idea:

%ul
  %li I created ~ann/app20 (done already)
  %li
    I created a simple one-line file named: ~ann/app20/Procfile
    %pre
      %code.bash echo 'web: node node_modules/http-server/bin/http-server -p $PORT' > ~ann/app20/Procfile
  %li git-init the app so I then have a git repo (done already)
  %li Create an account at heroku.com (done already)
  %li
    Download/Install Heroku client
    %pre
      %code.bash
        cd ~ann
        wget https://s3.amazonaws.com/assets.heroku.com/heroku-client/heroku-client.tgz
        tar zxf heroku-client.tgz
        echo 'export PATH=/home/ann/heroku-client/bin:${PATH}' >> ~ann/.bashrc
        echo  export PATH=/home/ann/heroku-client/bin:${PATH}


  %li
    I created ssh-key for ann account (assuming ann has none yet):
    %pre
      =render 'code_challenge2015_0919s'

  %li
    I used heroku-client to "login" my shell.
    I gave a copy of ann public ssh-key to heroku:
    %pre
      %code.bash
        heroku status
        heroku auth:login
        heroku auth:whoami
        heroku keys:add

  %li
    I used heroku-client to create a blank app named newyork212 at herokuapp.com
    %pre
      %code.bash
        cd ~ann/app20
        heroku create newyork212

  %li
    git-push ~ann/app20 to heroku
    %pre
      %code.bash
        cd ~ann/app20
        git add .
        git commit -am helloNY
        git push heroku master
    
  %li
    I saw ~ann/app20 deployed at 
    %a(href='https://newyork212.herokuapp.com/app/demo10.html' target='w')
      https://newyork212.herokuapp.com/app/demo10.html
%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo11.haml

%pre
  =render 'code_challenge2015_1010demo11'

demo10 showed us how to serve d3.v3.min.js and then get access to a JavaScript object named 'd3'.

%br/
%br/

demo11 does that, and then shows how to get realtime programatic control of an HTML p-element using a simple anonymous JavaScript function.

%br/
%br/

After I wrote demo11.haml,
I generated an HTML file from it using the haml shell command:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo11.haml ~ann/app20/app/demo11.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo11Hello
    git push heroku  master

I browsed this URL several times in a row:
%br/
%a(href='https://newyork212.herokuapp.com/app/demo11.html' target='w')
  https://newyork212.herokuapp.com/app/demo11.html
%br/
I noticed the p-elements changed color after each reload.
%br/
Compare this behavior to the behavior of demo10 which only serves white text.

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo12.haml 

%pre
  =render 'code_challenge2015_1010demo12'

demo12 enhances the idea behind demo11.

%br/
%br/

In demo11, all of the information which changes the p-elements comes from JavaScript.

%br/
%br/

In demo12, some of the information comes from JavaScript and some comes from the HTML.

%br/
%br/

This is a powerful concept.  It means that D3 can look at information in the HTML,
and then use that information to change the HTML.

%br/
%br/

For example, imagine my HTML contains a table-element with x and y values.

%br/
%br/

I can use D3 to read the x,y values into a JavaScript array.

%br/
%br/

The next obvious step is to build a chart from that array.

%br/
%br/

If the table changes every minute, D3 will update the chart automatically.

%br/
%br/

I demonstrate this table-chart idea at this URL:

%br/
%br/

%a(href='http://www.spy611.com/pred_lr' target='w')
  http://www.spy611.com/pred_lr

%br/
%br/

If I browse that URL with JavaScript disabled,
I only see a plain table.

%br/
%br/

If I enable JavaScript,
D3 builds a chart from the data in the table,
and it decorates the table based on the data in the table.

%br/
%br/

Anyway, after I wrote ~ann/app20/haml/demo12.haml 
I used the haml command to generate HTML from it:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo12.haml ~ann/app20/app/demo12.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo12Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo12.html' target='w')
  https://newyork212.herokuapp.com/app/demo12.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo13.haml 

%pre
  =render 'code_challenge2015_1010demo13'

The above demo shows how to attach a data source (in this case a simple JS array) to a selection of p-elements.

%br/
%br/

Each member of the data source is matched to a corresponding member of the p-element-selection.

%br/
%br/

After the match is made, a method is called which allows me to run an anonymous function against the match.

%br/
%br/

If I did not have D3 and had to do this by hand,
I would probably need to write a nested loop which has the outer-loop iterate through the
p-elements and an inner loop which selects an array element for each p-element.
Then the pair of objects would get fed to the anonymous function.

%br/
%br/


Anyway, after I wrote ~ann/app20/haml/demo13.haml 
I used the haml command to generate HTML from it:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo13.haml ~ann/app20/app/demo13.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo13Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo13.html' target='w')
  https://newyork212.herokuapp.com/app/demo13.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo14.haml 

%pre
  =render 'code_challenge2015_1010demo14'

The above haml file shows how to create p-elements from data source (a JS-array),
and then append them to the body element.

%br/
%br/

So, demo13.haml updates p-elements from a data source and demo14.haml creates elements from data.

%br/
%br/

I used the haml command to generate HTML from demo14.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo14.haml ~ann/app20/app/demo14.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo14Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo14.html' target='w')
  https://newyork212.herokuapp.com/app/demo14.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo15.haml 

%pre
  =render 'code_challenge2015_1010demo15'

The above syntax should do the same thing as demo14.haml.

%br/
%br/

The point of demo15 is to show how to break a long chain of D3 calls into pieces.

%br/
%br/

Perhaps when you see the pieces you will then understand the D3 API better?

%br/
%br/

I used the haml command to generate HTML from demo15.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo15.haml ~ann/app20/app/demo15.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo15Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo15.html' target='w')
  https://newyork212.herokuapp.com/app/demo15.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo16.haml 

%pre
  =render 'code_challenge2015_1010demo16'

The above haml file introduces some new API concepts:
%ul
  %li svg element
  %li circle element inside svg element
  %li transitions

An svg-element is created with help from SVG which has been supported by browsers for over 10 years:

%br/
%br/

%a(href='https://en.wikipedia.org/wiki/Scalable_Vector_Graphics' target='w')
  https://en.wikipedia.org/wiki/Scalable_Vector_Graphics

%br/
%br/

For example in demo16 I use two lines of HAML to create a blue circle.

%br/
%br/

I assume that D3 intends to wrap the SVG API in a way which makes it easier to use.

%br/
%br/

The next API-idea in demo16 is called 'transitions'.

%br/
%br/

I can use a transition when I want to change an element in a way which makes the change more evident to the user.

%br/
%br/

For example if I change the color or size of an element slowly rather than quickly,
the user might notice the change more easily.

%br/
%br/

I used the haml command to generate HTML from demo16.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo16.haml ~ann/app20/app/demo16.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo16Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo16.html' target='w')
  https://newyork212.herokuapp.com/app/demo16.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo17.haml 

%pre
  =render 'code_challenge2015_1010demo17'

The above file is the start of a simple bar chart demo.  The file contains only HAML and CSS.

%br/
%br/

I used the haml command to generate HTML from demo17.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo17.haml ~ann/app20/app/demo17.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo17Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo17.html' target='w')
  https://newyork212.herokuapp.com/app/demo17.html

%br/
%br/


%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo18.haml 

%pre
  =render 'code_challenge2015_1010demo18'

The above file uses a JS-array-data to drive two types of objects.

%br/
%br/

I use the data to create div-elements.

%br/
%br/

I use the data to fill the new div-elements with text.

%br/
%br/

I used the haml command to generate HTML from demo18.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo18.haml ~ann/app20/app/demo18.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo18Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo18.html' target='w')
  https://newyork212.herokuapp.com/app/demo18.html


%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo19.haml 

%pre
  =render 'code_challenge2015_1010demo19'

The above haml file offers the same behavior as demo18.haml

%br/
%br/

The point of demo19 is to show how to break a long chain of D3 calls into pieces.

%br/
%br/

Perhaps when you see the pieces you will then understand the D3 API better?

%br/
%br/

I used the haml command to generate HTML from demo19.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo19.haml ~ann/app20/app/demo19.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo19Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo19.html' target='w')
  https://newyork212.herokuapp.com/app/demo19.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo20.haml 

%pre
  =render 'code_challenge2015_1010demo20'

In demo20.haml I see how to create a function named, 'x()', which scales values in an array called data.

%br/
%br/

A synonym of the verb: 'scales' is, 'maps'.

%br/
%br/

The function, x() maps the min-value of data to 0 and maps the max-value of data to 800.

%br/
%br/

Then later in the file, I see how x() is actually called.

%br/
%br/

I used the haml command to generate HTML from demo20.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo20.haml ~ann/app20/app/demo20.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo20Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo20.html' target='w')
  https://newyork212.herokuapp.com/app/demo20.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo21.haml 

%pre
  =render 'code_challenge2015_1010demo21'

In demo21.haml I see how to duplicate the behavior of demo17.haml using plain SVG rather than div-elements.

%br/
%br/

The differences between the two files appear in two places:

%ul
  %li The CSS is different
  %li The element names are different

Another obvious difference is that the syntax in demo21.haml is more verbose than the syntax in demo17.haml

%br/
%br/

Note, however, that both files contain no JavaScript.

%br/
%br/

I used the haml command to generate HTML from demo21.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo21.haml ~ann/app20/app/demo21.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo21Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo21.html' target='w')
  https://newyork212.herokuapp.com/app/demo21.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo22.haml 

%pre
  =render 'code_challenge2015_1010demo22'

The above file enhances demo21.haml by showing how to connect the D3 API to SVG elements.

%br/
%br/

I used the haml command to generate HTML from demo22.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo22.haml ~ann/app20/app/demo22.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo22Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo22.html' target='w')
  https://newyork212.herokuapp.com/app/demo22.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo23.haml 

%pre
  =render 'code_challenge2015_1010demo23'

The above file enhances demo22.haml by showing how to replace an internal JS-array with external data file.

%br/
%br/

I used the haml command to generate HTML from demo23.haml:

%pre
  %code.bash 
    cd ~ann/app20/haml/
    \.  ~ann/app20/app20env.bash
    \~ann/app20/gems/bin/haml -eq ~ann/app20/haml/demo23.haml ~ann/app20/app/demo23.html

I deployed it to heroku.

%pre
  %code.bash 
    cd ~ann/app20
    git add .
    git commit -am demo23Hello
    git push heroku  master

I saw it here:

%br/

%a(href='https://newyork212.herokuapp.com/app/demo23.html' target='w')
  https://newyork212.herokuapp.com/app/demo23.html

%br/
%br/

%hr/

Next, using emacs, I started work on ~ann/app20/haml/demo24.haml 

%pre
  =render 'code_challenge2015_1010demo24'

The above file shows that I can move the JavaScript out of the HAML
into a separate file called this:
%br/
~ann/app20/app/demo24.js

%br/
%br/

A simple way to do that is a straight copy using emacs.

%br/
%br/

Another way is to start with a file full of CoffeeScript.

%br/
%br/

I created a CoffeeScript file at this path:
%br/
~ann/app20/fee/demo24.coffee

%pre
  =render 'code_challenge2015_1010f'

Then, I converted the CoffeeScript into JavaScript:

%br/
%br/


%br/
%br/

%h2 To be continued ...

%hr/
